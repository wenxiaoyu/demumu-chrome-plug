# HP（生命值）与活跃天数的关系说明

## 概念解释

### 1. HP（生命值）

**定义**: HP（Health Points）是用户的"生命值"，代表用户的活跃健康状态。

**初始值**: 100

**范围**: 0 - 100

**作用**: 
- 直观显示用户的活跃程度
- 作为"死亡"判定的重要指标之一
- 游戏化设计，增加用户粘性

---

### 2. 活跃天数（未活跃天数）

**定义**: 从用户最后一次敲击木鱼到现在经过的天数。

**计算方式**:
```typescript
const inactiveDays = Math.floor(
  (当前时间 - 最后敲击时间) / (1000 * 60 * 60 * 24)
);
```

**示例**:
- 最后敲击时间：2025-01-01 10:00
- 当前时间：2025-01-15 10:00
- 未活跃天数：14 天

---

## HP 的变化机制

### 增加 HP

**触发条件**: 每天首次敲击木鱼

**增加量**: +10 HP

**代码逻辑**:
```typescript
// 每日首次敲击奖励
if (isFirstKnockToday) {
  newHP = currentHP + 10;
  newHP = Math.min(100, newHP); // 不超过最大值 100
}
```

**示例**:
- 当前 HP：50
- 今天首次敲击 → HP 变为 60
- 今天第二次敲击 → HP 保持 60（不增加）

---

### 减少 HP

**触发条件**: 每过一天不敲击木鱼

**减少量**: -10 HP/天

**代码逻辑**:
```typescript
// 计算天数差
const daysDiff = getDaysDiff(lastKnockTime, now);

// 计算惩罚
const penalty = daysDiff * 10; // 每天 -10 HP
const newHP = currentHP - penalty;
newHP = Math.max(0, newHP); // 不低于最小值 0
```

**示例场景**:

**场景 1: 连续活跃**
- Day 1: 敲击木鱼，HP = 100
- Day 2: 敲击木鱼，HP = 100（保持满血）
- Day 3: 敲击木鱼，HP = 100

**场景 2: 偶尔不活跃**
- Day 1: 敲击木鱼，HP = 100
- Day 2: 没敲击，HP = 90（-10）
- Day 3: 敲击木鱼，HP = 100（+10，恢复满血）

**场景 3: 长期不活跃**
- Day 1: 敲击木鱼，HP = 100
- Day 2-11: 都没敲击
- Day 11: HP = 0（100 - 10×10 = 0）
- 此时触发"死亡"状态

---

## HP 与活跃天数的关联关系

### 关系类型：**因果关系**

```
未活跃天数 ↑ → HP ↓ → 可能触发"死亡"
```

### 详细说明

1. **HP 是结果，活跃天数是原因**
   - 用户不活跃（不敲击木鱼）→ 天数累积 → HP 减少
   - 用户活跃（敲击木鱼）→ 天数重置 → HP 恢复

2. **HP 是动态计算的**
   - HP 不是固定存储的值
   - 每次查询时，根据 `lastKnockTime` 和当前时间动态计算
   - 公式：`当前HP = 上次存储的HP - (未活跃天数 × 10)`

3. **两者都可以独立触发"死亡"**
   - HP <= 0 → 死亡（通常是 10 天不活跃导致）
   - 未活跃天数 >= 30 → 死亡（即使 HP 还有剩余）

---

## 死亡判定规则

### 规则 1: HP 检测

```typescript
if (userData.hp <= 0) {
  return { isDead: true, reason: "HP 低于阈值" };
}
```

**触发场景**: 用户连续 10 天不敲击木鱼

**计算**:
- 初始 HP：100
- 每天不敲击：-10 HP
- 10 天后：HP = 0
- 触发死亡判定

---

### 规则 2: 未活跃天数检测

```typescript
const inactiveDays = Math.floor(
  (Date.now() - userData.lastKnockTime) / (1000 * 60 * 60 * 24)
);

if (inactiveDays >= 30) {
  return { isDead: true, reason: "未活跃天数超过阈值" };
}
```

**触发场景**: 用户 30 天不敲击木鱼

**为什么需要这个规则？**
- 防止边界情况：用户可能通过某种方式保持 HP > 0 但长期不活跃
- 双重保险：确保长期不活跃的用户一定会被检测到
- 更合理的阈值：30 天比 10 天更能代表"真正的不活跃"

---

### 规则关系：OR（或）

```typescript
if (hp <= 0 || inactiveDays >= 30) {
  // 判定为死亡
}
```

**满足任意一个条件即判定为死亡**

---

## 实际场景示例

### 场景 1: 正常活跃用户

```
Day 1:  敲击 → HP = 100, 未活跃天数 = 0
Day 2:  敲击 → HP = 100, 未活跃天数 = 0
Day 3:  敲击 → HP = 100, 未活跃天数 = 0
...
结果: 永远不会触发死亡判定
```

---

### 场景 2: 偶尔忘记敲击

```
Day 1:  敲击 → HP = 100, 未活跃天数 = 0
Day 2:  忘记 → HP = 90,  未活跃天数 = 1
Day 3:  忘记 → HP = 80,  未活跃天数 = 2
Day 4:  敲击 → HP = 90,  未活跃天数 = 0 (重置)
Day 5:  敲击 → HP = 100, 未活跃天数 = 0
...
结果: HP 恢复，不会触发死亡判定
```

---

### 场景 3: 连续 10 天不活跃（触发规则 1）

```
Day 1:  敲击 → HP = 100, 未活跃天数 = 0
Day 2:  不敲 → HP = 90,  未活跃天数 = 1
Day 3:  不敲 → HP = 80,  未活跃天数 = 2
Day 4:  不敲 → HP = 70,  未活跃天数 = 3
Day 5:  不敲 → HP = 60,  未活跃天数 = 4
Day 6:  不敲 → HP = 50,  未活跃天数 = 5
Day 7:  不敲 → HP = 40,  未活跃天数 = 6
Day 8:  不敲 → HP = 30,  未活跃天数 = 7
Day 9:  不敲 → HP = 20,  未活跃天数 = 8
Day 10: 不敲 → HP = 10,  未活跃天数 = 9
Day 11: 不敲 → HP = 0,   未活跃天数 = 10

✅ 触发死亡判定（规则 1: HP <= 0）
```

---

### 场景 4: 连续 30 天不活跃（触发规则 2）

```
Day 1:  敲击 → HP = 100, 未活跃天数 = 0
Day 2-11: 不敲 → HP = 0, 未活跃天数 = 10
Day 12-30: 不敲 → HP = 0, 未活跃天数 = 11-29
Day 31: 不敲 → HP = 0, 未活跃天数 = 30

✅ 触发死亡判定（规则 2: 未活跃天数 >= 30）
```

**注意**: 实际上在 Day 11 就已经触发规则 1 了，但规则 2 作为双重保险。

---

### 场景 5: 边界情况（假设 HP 可以通过其他方式恢复）

```
假设用户通过某种方式每 9 天恢复一次 HP：

Day 1:  敲击 → HP = 100, 未活跃天数 = 0
Day 2-10: 不敲 → HP = 10, 未活跃天数 = 9
Day 11: 恢复 HP → HP = 100, 未活跃天数 = 10
Day 12-20: 不敲 → HP = 10, 未活跃天数 = 19
Day 21: 恢复 HP → HP = 100, 未活跃天数 = 20
...
Day 31: → HP = 100, 未活跃天数 = 30

✅ 触发死亡判定（规则 2: 未活跃天数 >= 30）
```

**这就是为什么需要规则 2**: 即使 HP 保持 > 0，30 天不活跃也应该判定为"死亡"。

---

## 数据存储

### userData 集合中的相关字段

```typescript
{
  lastKnockTime: 1704067200000,  // 最后敲击时间（毫秒时间戳）
  hp: 100,                        // 当前存储的 HP
  // ... 其他字段
}
```

### 重要说明

1. **lastKnockTime 是关键字段**
   - 用于计算未活跃天数
   - 用于动态计算当前 HP

2. **hp 字段是"快照"**
   - 存储的是最后一次更新时的 HP
   - 实际 HP 需要根据 lastKnockTime 动态计算

3. **后端检测时需要动态计算**
   ```typescript
   // 不能直接使用 userData.hp
   // 需要根据 lastKnockTime 计算当前实际 HP
   const daysDiff = Math.floor(
     (Date.now() - userData.lastKnockTime) / (1000 * 60 * 60 * 24)
   );
   const actualHP = userData.hp - (daysDiff * 10);
   const finalHP = Math.max(0, actualHP);
   ```

---

## 总结

### HP 和活跃天数的关系

| 维度 | HP | 活跃天数 |
|------|----|----|
| **定义** | 用户的生命值（0-100） | 从最后敲击到现在的天数 |
| **性质** | 动态计算的结果 | 时间差的计算结果 |
| **变化方式** | 每天不敲击 -10，首次敲击 +10 | 随时间自然增长，敲击后重置为 0 |
| **死亡阈值** | <= 0 | >= 30 天 |
| **触发时间** | 约 10 天不活跃 | 30 天不活跃 |
| **关系** | 因果关系：不活跃 → HP 下降 | 独立判定，双重保险 |

### 为什么需要两个规则？

1. **HP 规则（10 天）**: 
   - 更快速的预警
   - 游戏化设计，用户可以看到 HP 下降
   - 鼓励用户保持活跃

2. **活跃天数规则（30 天）**:
   - 更保守的判定
   - 防止边界情况
   - 确保长期不活跃一定会被检测到

3. **OR 关系**:
   - 满足任意一个即判定为死亡
   - 双重保险，更可靠

---

## 后端实现建议

```typescript
function checkUserDeathStatus(userData: any): {
  isDead: boolean;
  reason: string;
} {
  // 规则 1: HP 检测
  // 注意：需要动态计算当前 HP
  const daysDiff = Math.floor(
    (Date.now() - userData.lastKnockTime) / (1000 * 60 * 60 * 24)
  );
  const actualHP = Math.max(0, userData.hp - (daysDiff * 10));
  
  if (actualHP <= 0) {
    return {
      isDead: true,
      reason: `HP 低于阈值 (${actualHP} <= 0)`
    };
  }
  
  // 规则 2: 未活跃天数检测
  const inactiveDays = daysDiff;
  
  if (inactiveDays >= 30) {
    return {
      isDead: true,
      reason: `未活跃天数超过阈值 (${inactiveDays} >= 30)`
    };
  }
  
  return {
    isDead: false,
    reason: '状态正常'
  };
}
```

---

**希望这个说明能帮助你理解 HP 和活跃天数的关系！** 🎮
